diff --git a/dist/autocomplete.js b/dist/autocomplete.js
index 5458ba7c993d7c19b444df20a1e3b83b114e2241..62e2cf6c687bed63edc6f21af9d8a585c1bc29f1 100644
--- a/dist/autocomplete.js
+++ b/dist/autocomplete.js
@@ -52,7 +52,7 @@ function useAutocomplete(originalProps) {
   const { validationBehavior: formValidationBehavior } = (0, import_form.useSlottedContext)(import_form.FormContext) || {};
   const [props, variantProps] = (0, import_system.mapPropsVariants)(originalProps, import_theme.autocomplete.variantKeys);
   const disableAnimation = (_b = (_a = originalProps.disableAnimation) != null ? _a : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _b : false;
-  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isReadOnly ? false : originalProps.isClearable;
+  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isDisabled ? false : originalProps.isReadOnly ? false : originalProps.isClearable;
   const {
     ref,
     as,
@@ -87,6 +87,7 @@ function useAutocomplete(originalProps) {
     errorMessage,
     onOpenChange,
     onClose,
+    onClear,
     isReadOnly = false,
     ...otherProps
   } = props;
@@ -216,12 +217,29 @@ function useAutocomplete(originalProps) {
     }
   }, [inputRef.current]);
   (0, import_react.useEffect)(() => {
-    let key = state.collection.getFirstKey();
-    while (key && state.disabledKeys.has(key)) {
-      key = state.collection.getKeyAfter(key);
+    let keyToFocus;
+    if (state.selectedKey !== null && state.collection.getItem(state.selectedKey) && !state.disabledKeys.has(state.selectedKey)) {
+      keyToFocus = state.selectedKey;
+    } else {
+      let firstAvailableKey = state.collection.getFirstKey();
+      while (firstAvailableKey && state.disabledKeys.has(firstAvailableKey)) {
+        firstAvailableKey = state.collection.getKeyAfter(firstAvailableKey);
+      }
+      keyToFocus = firstAvailableKey;
+    }
+    state.selectionManager.setFocusedKey(keyToFocus);
+  }, [state.collection, state.disabledKeys, state.selectedKey]);
+  (0, import_react.useEffect)(() => {
+    if (state.isOpen && popoverRef.current && listBoxRef.current) {
+      let selectedItem = listBoxRef.current.querySelector("[aria-selected=true] [data-label=true]");
+      let scrollShadow = scrollShadowRef.current;
+      if (selectedItem && scrollShadow && selectedItem.parentElement) {
+        let scrollShadowRect = scrollShadow == null ? void 0 : scrollShadow.getBoundingClientRect();
+        let scrollShadowHeight = scrollShadowRect.height;
+        scrollShadow.scrollTop = selectedItem.parentElement.offsetTop - scrollShadowHeight / 2 + selectedItem.parentElement.clientHeight / 2;
+      }
     }
-    state.selectionManager.setFocusedKey(key);
-  }, [state.collection, state.disabledKeys]);
+  }, [state.isOpen, disableAnimation]);
   (0, import_react.useEffect)(() => {
     if (isOpen) {
       if (popoverRef.current && inputWrapperRef.current) {
@@ -270,7 +288,9 @@ function useAutocomplete(originalProps) {
   const getClearButtonProps = () => {
     var _a2, _b2;
     return {
-      ...(0, import_utils.mergeProps)(buttonProps, slotsProps.clearButtonProps),
+      ...slotsProps.clearButtonProps,
+      preventFocusOnPress: true,
+      excludeFromTabOrder: true,
       onPressStart: () => {
         var _a3;
         (_a3 = inputRef.current) == null ? void 0 : _a3.focus();
@@ -283,6 +303,7 @@ function useAutocomplete(originalProps) {
         }
         state.setInputValue("");
         state.open();
+        onClear?.();
       },
       "data-visible": !!state.selectedItem || ((_a2 = state.inputValue) == null ? void 0 : _a2.length) > 0,
       className: slots.clearButton({
@@ -435,7 +456,7 @@ var Autocomplete = (0, import_system2.forwardRef)(function Autocomplete2(props,
         ...getInputProps(),
         endContent: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { ...getEndContentWrapperProps(), children: [
           endContent || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_button.Button, { ...getClearButtonProps(), children: clearIcon }),
-          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_button.Button, { ...getSelectorButtonProps(), children: selectorIcon })
+          selectorIcon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_button.Button, { ...getSelectorButtonProps(), children: selectorIcon })
         ] })
       }
     ),
diff --git a/dist/chunk-QZCVHGAT.mjs b/dist/chunk-QZCVHGAT.mjs
index f54795f69c1f19e73f04e22b19be8cd2c431fa67..20e747ee65761d84a5c8bbe388fdd1d54b1da340 100644
--- a/dist/chunk-QZCVHGAT.mjs
+++ b/dist/chunk-QZCVHGAT.mjs
@@ -19,7 +19,7 @@ function useAutocomplete(originalProps) {
   const { validationBehavior: formValidationBehavior } = useSlottedContext(FormContext) || {};
   const [props, variantProps] = mapPropsVariants(originalProps, autocomplete.variantKeys);
   const disableAnimation = (_b = (_a = originalProps.disableAnimation) != null ? _a : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _b : false;
-  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isReadOnly ? false : originalProps.isClearable;
+  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isDisabled ? false : originalProps.isReadOnly ? false : originalProps.isClearable;
   const {
     ref,
     as,
@@ -54,6 +54,7 @@ function useAutocomplete(originalProps) {
     errorMessage,
     onOpenChange,
     onClose,
+    onClear,
     isReadOnly = false,
     ...otherProps
   } = props;
@@ -183,12 +184,29 @@ function useAutocomplete(originalProps) {
     }
   }, [inputRef.current]);
   useEffect(() => {
-    let key = state.collection.getFirstKey();
-    while (key && state.disabledKeys.has(key)) {
-      key = state.collection.getKeyAfter(key);
+    let keyToFocus;
+    if (state.selectedKey !== null && state.collection.getItem(state.selectedKey) && !state.disabledKeys.has(state.selectedKey)) {
+      keyToFocus = state.selectedKey;
+    } else {
+      let firstAvailableKey = state.collection.getFirstKey();
+      while (firstAvailableKey && state.disabledKeys.has(firstAvailableKey)) {
+        firstAvailableKey = state.collection.getKeyAfter(firstAvailableKey);
+      }
+      keyToFocus = firstAvailableKey;
+    }
+    state.selectionManager.setFocusedKey(keyToFocus);
+  }, [state.collection, state.disabledKeys, state.selectedKey]);
+  useEffect(() => {
+    if (state.isOpen && popoverRef.current && listBoxRef.current) {
+      let selectedItem = listBoxRef.current.querySelector("[aria-selected=true] [data-label=true]");
+      let scrollShadow = scrollShadowRef.current;
+      if (selectedItem && scrollShadow && selectedItem.parentElement) {
+        let scrollShadowRect = scrollShadow == null ? void 0 : scrollShadow.getBoundingClientRect();
+        let scrollShadowHeight = scrollShadowRect.height;
+        scrollShadow.scrollTop = selectedItem.parentElement.offsetTop - scrollShadowHeight / 2 + selectedItem.parentElement.clientHeight / 2;
+      }
     }
-    state.selectionManager.setFocusedKey(key);
-  }, [state.collection, state.disabledKeys]);
+  }, [state.isOpen, disableAnimation]);
   useEffect(() => {
     if (isOpen) {
       if (popoverRef.current && inputWrapperRef.current) {
@@ -237,7 +255,9 @@ function useAutocomplete(originalProps) {
   const getClearButtonProps = () => {
     var _a2, _b2;
     return {
-      ...mergeProps(buttonProps, slotsProps.clearButtonProps),
+      ...slotsProps.clearButtonProps,
+      preventFocusOnPress: true,
+      excludeFromTabOrder: true,
       onPressStart: () => {
         var _a3;
         (_a3 = inputRef.current) == null ? void 0 : _a3.focus();
@@ -250,6 +270,7 @@ function useAutocomplete(originalProps) {
         }
         state.setInputValue("");
         state.open();
+        onClear?.();
       },
       "data-visible": !!state.selectedItem || ((_a2 = state.inputValue) == null ? void 0 : _a2.length) > 0,
       className: slots.clearButton({
diff --git a/dist/chunk-SV7R5B4H.mjs b/dist/chunk-SV7R5B4H.mjs
index 09b37df32ed4cdcccf6df45c0891039422ec0195..d3018f6f3f6f05af689f2a5465532233ea356759 100644
--- a/dist/chunk-SV7R5B4H.mjs
+++ b/dist/chunk-SV7R5B4H.mjs
@@ -41,7 +41,7 @@ var Autocomplete = forwardRef(function Autocomplete2(props, ref) {
         ...getInputProps(),
         endContent: /* @__PURE__ */ jsxs("div", { ...getEndContentWrapperProps(), children: [
           endContent || /* @__PURE__ */ jsx(Button, { ...getClearButtonProps(), children: clearIcon }),
-          /* @__PURE__ */ jsx(Button, { ...getSelectorButtonProps(), children: selectorIcon })
+          selectorIcon && /* @__PURE__ */ jsx(Button, { ...getSelectorButtonProps(), children: selectorIcon })
         ] })
       }
     ),
diff --git a/dist/index.js b/dist/index.js
index 7ffc5983a0132b2178ebe4ca2187bc8ab67f4e6b..1a38fc237b56d1e81c687e3d85b74df2475812d0 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -58,7 +58,7 @@ function useAutocomplete(originalProps) {
   const { validationBehavior: formValidationBehavior } = (0, import_form.useSlottedContext)(import_form.FormContext) || {};
   const [props, variantProps] = (0, import_system.mapPropsVariants)(originalProps, import_theme.autocomplete.variantKeys);
   const disableAnimation = (_b = (_a = originalProps.disableAnimation) != null ? _a : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _b : false;
-  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isReadOnly ? false : originalProps.isClearable;
+  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isDisabled ? false : originalProps.isReadOnly ? false : originalProps.isClearable;
   const {
     ref,
     as,
@@ -93,6 +93,7 @@ function useAutocomplete(originalProps) {
     errorMessage,
     onOpenChange,
     onClose,
+    onClear,
     isReadOnly = false,
     ...otherProps
   } = props;
@@ -222,12 +223,29 @@ function useAutocomplete(originalProps) {
     }
   }, [inputRef.current]);
   (0, import_react.useEffect)(() => {
-    let key = state.collection.getFirstKey();
-    while (key && state.disabledKeys.has(key)) {
-      key = state.collection.getKeyAfter(key);
+    let keyToFocus;
+    if (state.selectedKey !== null && state.collection.getItem(state.selectedKey) && !state.disabledKeys.has(state.selectedKey)) {
+      keyToFocus = state.selectedKey;
+    } else {
+      let firstAvailableKey = state.collection.getFirstKey();
+      while (firstAvailableKey && state.disabledKeys.has(firstAvailableKey)) {
+        firstAvailableKey = state.collection.getKeyAfter(firstAvailableKey);
+      }
+      keyToFocus = firstAvailableKey;
+    }
+    state.selectionManager.setFocusedKey(keyToFocus);
+  }, [state.collection, state.disabledKeys, state.selectedKey]);
+  (0, import_react.useEffect)(() => {
+    if (state.isOpen && popoverRef.current && listBoxRef.current) {
+      let selectedItem = listBoxRef.current.querySelector("[aria-selected=true] [data-label=true]");
+      let scrollShadow = scrollShadowRef.current;
+      if (selectedItem && scrollShadow && selectedItem.parentElement) {
+        let scrollShadowRect = scrollShadow == null ? void 0 : scrollShadow.getBoundingClientRect();
+        let scrollShadowHeight = scrollShadowRect.height;
+        scrollShadow.scrollTop = selectedItem.parentElement.offsetTop - scrollShadowHeight / 2 + selectedItem.parentElement.clientHeight / 2;
+      }
     }
-    state.selectionManager.setFocusedKey(key);
-  }, [state.collection, state.disabledKeys]);
+  }, [state.isOpen, disableAnimation]);
   (0, import_react.useEffect)(() => {
     if (isOpen) {
       if (popoverRef.current && inputWrapperRef.current) {
@@ -276,7 +294,9 @@ function useAutocomplete(originalProps) {
   const getClearButtonProps = () => {
     var _a2, _b2;
     return {
-      ...(0, import_utils.mergeProps)(buttonProps, slotsProps.clearButtonProps),
+      ...slotsProps.clearButtonProps,
+      preventFocusOnPress: true,
+      excludeFromTabOrder: true,
       onPressStart: () => {
         var _a3;
         (_a3 = inputRef.current) == null ? void 0 : _a3.focus();
@@ -289,6 +309,7 @@ function useAutocomplete(originalProps) {
         }
         state.setInputValue("");
         state.open();
+        onClear?.();
       },
       "data-visible": !!state.selectedItem || ((_a2 = state.inputValue) == null ? void 0 : _a2.length) > 0,
       className: slots.clearButton({
@@ -441,7 +462,7 @@ var Autocomplete = (0, import_system2.forwardRef)(function Autocomplete2(props,
         ...getInputProps(),
         endContent: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { ...getEndContentWrapperProps(), children: [
           endContent || /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_button.Button, { ...getClearButtonProps(), children: clearIcon }),
-          /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_button.Button, { ...getSelectorButtonProps(), children: selectorIcon })
+          selectorIcon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_button.Button, { ...getSelectorButtonProps(), children: selectorIcon })
         ] })
       }
     ),
diff --git a/dist/use-autocomplete.d.ts b/dist/use-autocomplete.d.ts
index b67a788f8919ace339e89326cff3eed90e7f5273..a827006f6431777d9643a0454904a9792aa77ea1 100644
--- a/dist/use-autocomplete.d.ts
+++ b/dist/use-autocomplete.d.ts
@@ -105,6 +105,11 @@ interface Props<T> extends Omit<HTMLHeroUIProps<"input">, keyof ComboBoxProps<T>
      * Callback fired when the select menu is closed.
      */
     onClose?: () => void;
+    /**
+     * Callback fired when the value is cleared.
+     * if you pass this prop, the clear button will be shown.
+     */
+    onClear?: () => void;
     /**
      * Whether to enable virtualization of the listbox items.
      * By default, virtualization is automatically enabled when the number of items is greater than 50.
diff --git a/dist/use-autocomplete.js b/dist/use-autocomplete.js
index e644781853f6341121165125832f86e9996c69e4..04bc9302d245a1651f27656fb9abd8c09aec518b 100644
--- a/dist/use-autocomplete.js
+++ b/dist/use-autocomplete.js
@@ -42,7 +42,7 @@ function useAutocomplete(originalProps) {
   const { validationBehavior: formValidationBehavior } = (0, import_form.useSlottedContext)(import_form.FormContext) || {};
   const [props, variantProps] = (0, import_system.mapPropsVariants)(originalProps, import_theme.autocomplete.variantKeys);
   const disableAnimation = (_b = (_a = originalProps.disableAnimation) != null ? _a : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _b : false;
-  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isReadOnly ? false : originalProps.isClearable;
+  const isClearable = originalProps.disableClearable !== void 0 ? !originalProps.disableClearable : originalProps.isDisabled ? false : originalProps.isReadOnly ? false : originalProps.isClearable;
   const {
     ref,
     as,
@@ -77,6 +77,7 @@ function useAutocomplete(originalProps) {
     errorMessage,
     onOpenChange,
     onClose,
+    onClear,
     isReadOnly = false,
     ...otherProps
   } = props;
@@ -206,12 +207,29 @@ function useAutocomplete(originalProps) {
     }
   }, [inputRef.current]);
   (0, import_react.useEffect)(() => {
-    let key = state.collection.getFirstKey();
-    while (key && state.disabledKeys.has(key)) {
-      key = state.collection.getKeyAfter(key);
+    let keyToFocus;
+    if (state.selectedKey !== null && state.collection.getItem(state.selectedKey) && !state.disabledKeys.has(state.selectedKey)) {
+      keyToFocus = state.selectedKey;
+    } else {
+      let firstAvailableKey = state.collection.getFirstKey();
+      while (firstAvailableKey && state.disabledKeys.has(firstAvailableKey)) {
+        firstAvailableKey = state.collection.getKeyAfter(firstAvailableKey);
+      }
+      keyToFocus = firstAvailableKey;
+    }
+    state.selectionManager.setFocusedKey(keyToFocus);
+  }, [state.collection, state.disabledKeys, state.selectedKey]);
+  (0, import_react.useEffect)(() => {
+    if (state.isOpen && popoverRef.current && listBoxRef.current) {
+      let selectedItem = listBoxRef.current.querySelector("[aria-selected=true] [data-label=true]");
+      let scrollShadow = scrollShadowRef.current;
+      if (selectedItem && scrollShadow && selectedItem.parentElement) {
+        let scrollShadowRect = scrollShadow == null ? void 0 : scrollShadow.getBoundingClientRect();
+        let scrollShadowHeight = scrollShadowRect.height;
+        scrollShadow.scrollTop = selectedItem.parentElement.offsetTop - scrollShadowHeight / 2 + selectedItem.parentElement.clientHeight / 2;
+      }
     }
-    state.selectionManager.setFocusedKey(key);
-  }, [state.collection, state.disabledKeys]);
+  }, [state.isOpen, disableAnimation]);
   (0, import_react.useEffect)(() => {
     if (isOpen) {
       if (popoverRef.current && inputWrapperRef.current) {
@@ -260,7 +278,9 @@ function useAutocomplete(originalProps) {
   const getClearButtonProps = () => {
     var _a2, _b2;
     return {
-      ...(0, import_utils.mergeProps)(buttonProps, slotsProps.clearButtonProps),
+      ...slotsProps.clearButtonProps,
+      preventFocusOnPress: true,
+      excludeFromTabOrder: true,
       onPressStart: () => {
         var _a3;
         (_a3 = inputRef.current) == null ? void 0 : _a3.focus();
@@ -273,6 +293,7 @@ function useAutocomplete(originalProps) {
         }
         state.setInputValue("");
         state.open();
+        onClear?.();
       },
       "data-visible": !!state.selectedItem || ((_a2 = state.inputValue) == null ? void 0 : _a2.length) > 0,
       className: slots.clearButton({
